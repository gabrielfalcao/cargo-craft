{% if craft_subcommands %}
use clap::{Parser, Subcommand};
{% else %}
use clap::{Parser /*, Subcommand*/};
{% endif %}
{% if craft_lib %}
use {{ package_name }}::{Result, Error, Exit};
{% if craft_subcommands %}
use {{ package_name }}::dispatch::{ParserDispatcher, SubcommandDispatcher, ArgsDispatcher};
{% else %}
use {{ package_name }}::dispatch::{ParserDispatcher /*, SubcommandDispatcher, ArgsDispatcher*/};
{% endif %}
{% endif %}
{% if craft_value_enum %}
use clap::builder::PossibleValue;
use clap::ValueEnum;
{% endif %}

#[derive(Parser, Debug, Clone)]
#[command(author, version, about, long_about = "{{ crate_name }}{% if craft_cli %} command-line{% else %}{% endif %}")]
pub struct Cli {
    {% if craft_subcommands %}
    #[command(subcommand)]
    command: Command,
    {% else %}
    #[arg()]
    text: Vec<String>,
    {% if craft_value_enum %}
    #[arg(short, long, default_value = "out")]
    std: Std,
    {% endif %}
    {% endif %}
}
impl Cli {
{% if craft_subcommands %}
    pub fn command(&self) -> Command {
        self.command.clone()
    }
{% else %}
    pub fn text(&self) -> String {
        self.text.join(" ")
    }
{% endif %}
}

impl ParserDispatcher<Error> for Cli {
    fn dispatch(&self) -> Result<()> {
        {% if craft_subcommands %}
        self.command.dispatch()?;
        {% else %}
            {% if craft_value_enum %}
            match &self.std {
                Std::Out => {
                    println!("{}", &self.text());
                },
                Std::Err => {
                    eprintln!("{}", &self.text());
                },
            }
            {% else %}
            println!("{}", &self.text());
            {% endif %}
        {% endif %}
        Ok(())
    }
}


{% if craft_value_enum %}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum Std {
    Err,
    Out,
}
impl std::fmt::Display for Std {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match &self {
                Std::Err => "err",
                Std::Out => "out",
            }
        )
    }
}
impl ValueEnum for Std {
    fn value_variants<'a>() -> &'a [Self] {
        &[
            Std::Err,
            Std::Out,
        ]
    }

    fn to_possible_value(&self) -> Option<PossibleValue> {
        Some(
            PossibleValue::new(self.to_string())
                .alias(self.to_string().to_lowercase())
                .alias(self.to_string().to_uppercase()),
        )
    }

    fn from_str(input: &str, ignore_case: bool) -> std::result::Result<Std, String> {
        let input = if ignore_case { input.to_lowercase() } else { input.to_string() };
        let input = input.trim();

        Ok(match input.to_lowercase().as_str() {
            "err" => Std::Err,
            "out" => Std::Out,
            unknown => return Err(unknown.to_string()),
        })
    }
}
{% endif %}


{% if craft_subcommands %}
    #[derive(Subcommand, Debug, Clone)]
    pub enum Command {
        Hello(HelloOpt),
    }
    impl SubcommandDispatcher<Error> for Command {
        fn dispatch(&self) -> Result<()> {
            match self {
                Command::Hello(op) => op.dispatch()?,
            }
            Ok(())
        }
    }

    #[derive(Parser, Debug, Clone)]
    pub struct HelloOpt {
        #[arg()]
        text: Vec<String>,
    {% if craft_value_enum %}
        #[arg(short, long, default_value = "out")]
        std: Std,
    {% endif %}
    }
    impl HelloOpt {
        pub fn text(&self) -> String {
            self.text.join(" ")
        }
    }
    impl ArgsDispatcher<Error> for HelloOpt {
        fn dispatch(&self) -> Result<()> {
            {% if craft_value_enum %}
            match &self.std {
                Std::Out => {
                    println!("{}", &self.text());
                },
                Std::Err => {
                    eprintln!("{}", &self.text());
                },
            }
            {% else %}
            println!("{}", &self.text());
            {% endif %}
            Ok(())
        }
    }
{% endif %}

fn main() -> Exit {
    Cli::main()
}

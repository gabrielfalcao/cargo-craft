pub  trait ParserDispatcher<E: std::error::Error>: clap::Parser
where
    crate::Exit: From<std::result::Result<(), E>>,
{
    fn dispatch(&self) -> Result<(), E>;
    fn dispatch_cargo(&self) -> Result<(), E> {
        Ok(self.dispatch()?)
    }
    fn run() -> Result<(), E> {
        let (args, is_cargo) = Self::args();
        if is_cargo {
            Self::dispatch_cargo(&Self::parse_from(&args))?;
        } else {
            Self::dispatch(&Self::parse_from(&args))?;
        }
        Ok(())
    }
    fn main() -> crate::Exit {
        Self::run().into()
    }
    fn args() -> (Vec<String>, bool) {
        let argv = iocore::env::args();
        {% if is_cargo_command %}
        let argc = argv.len();
        let execname = iocore::Path::new(&argv[0]).name();
        let shift_args = (execname == "cargo" && argc > 1) {% for entry in crate_binaries %}{% if entry.is_cargo %}
        || (argc > 1 && (execname == "cargo" || execname == "{{entry["name"]}}") && argv[1].to_string() == "{{ entry.cargo_subcommand }}")
        {% endif %}{% endfor %};
        let is_cargo = execname == "cargo" {% for entry in crate_binaries %}{% if entry.is_cargo %}
        || execname == "{{entry["name"]}}"
        {% endif %}{% endfor %};
        let args = if shift_args { argv[1..].to_vec() } else { argv.to_vec() };
        (args, is_cargo)
        {% else %}
        (argv, false)
        {% endif %}
    }
}
pub  trait SubcommandDispatcher<E: std::error::Error>: clap::Subcommand {
    fn dispatch(&self) -> Result<(), E>;
}

pub  trait ArgsDispatcher<E: std::error::Error>: clap::Args {
    fn dispatch(&self) -> Result<(), E>;
}
